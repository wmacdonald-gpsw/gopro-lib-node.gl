#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 2) uniform Simulation {
    float time;
    float duration;
} simulation;
layout(binding = 1) buffer Parameters {
    vec3 position[2048];
    vec2 velocity[2048];
} parameters;

layout(binding = 0) buffer Output {
    vec3 position[];
} result;

float bounceOut(float t)
{
    float c = 1.0;
    float a = 1.70158;

    if (t >= 1.0) {
        return c;
    } else if (t < 4.0 / 11.0) {
        return c * (7.5625 * t * t);
    } else if (t < 8.0 / 11.0) {
        t -= 6.0 / 11.0;
        return -a * (1.0 - (7.5625 * t * t + 0.75)) + c;
    } else if (t < 10.0 / 11.0) {
        t -= 9.0 / 11.0;
        return -a * (1.0 - (7.5625 * t * t + 0.9375)) + c;
    } else {
        t -= 21.0 / 22.0;
        return -a * (1.0 - (7.5625 * t * t + 0.984375)) + c;
    }
}

float bounce(float t)
{
    return 1.0 - bounceOut(t);
}

void main(void)
{
    uint i = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x;
    vec3 position = parameters.position[i];
    vec2 velocity = parameters.velocity[i];

    float step = simulation.time * simulation.duration * 30.0;
    float yoffset = 1.0 - position.y;
    float speed = 1.0 + velocity.y;

    float new_position_x = position.x + step * velocity.x;
    float new_position_y = ((2.0 - yoffset) * bounce(simulation.time * speed * (1.0  + yoffset))) - 0.99;

    result.position[i] = vec3(new_position_x, 1.0 - new_position_y - 1.0, position.z);
}
